<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Combination and Variation Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #F5F5F5;
            text-align: center;
            padding: 20px;
        }
        input[type="text"], input[type="range"] {
            margin: 5px;
        }
        /* --- NEW STYLES FOR COLOR PICKER SQUARE --- */
        .picker-wrapper {
            display: inline-flex;
            align-items: center;
            vertical-align: middle;
        }
        .color-picker-sq {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            background-color: transparent;
            border: 1px solid #ccc;
            cursor: pointer;
            padding: 0;
            margin-right: 2px;
        }
        .color-picker-sq::-webkit-color-swatch {
            border: none;
            padding: 0;
        }
        .color-picker-sq::-moz-color-swatch {
            border: none;
            padding: 0;
        }
        /* ----------------------------------------- */
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            justify-content: center;
        }
        .color-box {
            position: relative;
            width: 100px;
            height: 100px;
            border: 1px solid #ccc;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .color-label {
            position: absolute;
            bottom: 0;
            width: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            text-align: center;
            padding: 2px 0;
            font-size: 12px;
        }
        .slider-label {
            display: inline-block;
            width: 80px;
        }
        .copied {
            color: green;
            font-size: 14px;
            margin-top: 10px;
        }
        /* --- NEW STYLES FOR IMAGE PALETTE --- */
        #image-canvas {
            /* Canvas drawing area is always 256x256, but its content is scaled. */
            border: 2px dashed #007bff;
            cursor: crosshair;
            display: block; 
            margin: 0 auto;
        }
        #image-drop-area {
            width: 256px;
            height: 256px;
            max-width: 100%;
            max-height: 256px;
            margin: 20px auto 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #e9ecef;
            border: 2px dashed #6c757d;
            border-radius: 5px;
            position: relative;
        }
        #image-drop-area p {
            position: absolute;
            pointer-events: none;
            text-align: center;
            padding: 10px;
            color: #495057;
        }
    </style>
    <script src="../js/colorConversion.js"></script>
</head>
<body>
	<a href=".." style="position:absolute;left: 1em;top: .6em;">Menu</a>
    <h1>Color Combination and Variation Tool</h1>
    <p>Enter up to four colors (hex or named) and see various combinations and variations.</p>

    <hr>
    <h2>Mixer 1</h2>

    <div>
        <div class="picker-wrapper">
            <input type="color" id="pick1" class="color-picker-sq" oninput="syncPickerToText(1, 1)">
            <input type="text" id="color1" placeholder="yellow" oninput="updateColors(1); syncTextToPicker(1)">
            <input type="range" id="weight1" min="0" max="100" value="25" oninput="updateColors(1)">
            <span id="closestColor1"></span>
        </div><br>
        
        <div class="picker-wrapper">
            <input type="color" id="pick2" class="color-picker-sq" oninput="syncPickerToText(2, 1)">
            <input type="text" id="color2" placeholder="#00FF00" oninput="updateColors(1); syncTextToPicker(2)">
            <input type="range" id="weight2" min="0" max="100" value="25" oninput="updateColors(1)">
            <span id="closestColor2"></span>
        </div><br>

        <div class="picker-wrapper">
            <input type="color" id="pick3" class="color-picker-sq" oninput="syncPickerToText(3, 1)">
            <input type="text" id="color3" placeholder="#0000FF" oninput="updateColors(1); syncTextToPicker(3)">
            <input type="range" id="weight3" min="0" max="100" value="25" oninput="updateColors(1)">
            <span id="closestColor3"></span>
        </div><br>

        <div class="picker-wrapper">
            <input type="color" id="pick4" class="color-picker-sq" oninput="syncPickerToText(4, 1)">
            <input type="text" id="color4" placeholder="#FFFF00" oninput="updateColors(1); syncTextToPicker(4)">
            <input type="range" id="weight4" min="0" max="100" value="25" oninput="updateColors(1)">
            <span id="closestColor4"></span>
        </div>
    </div>

    <div class="grid" id="results1"></div>
    <div id="copied-message1" class="copied"></div>

    <hr>
    
    <h2>Mixer 2</h2>

    <div>
        <div class="picker-wrapper">
            <input type="color" id="pick5" class="color-picker-sq" oninput="syncPickerToText(5, 2)">
            <input type="text" id="color5" placeholder="#FF0000" oninput="updateColors(2); syncTextToPicker(5)">
            <input type="range" id="weight5" min="0" max="100" value="25" oninput="updateColors(2)">
            <span id="closestColor5"></span>
        </div><br>

        <div class="picker-wrapper">
            <input type="color" id="pick6" class="color-picker-sq" oninput="syncPickerToText(6, 2)">
            <input type="text" id="color6" placeholder="#00FF00" oninput="updateColors(2); syncTextToPicker(6)">
            <input type="range" id="weight6" min="0" max="100" value="25" oninput="updateColors(2)">
            <span id="closestColor6"></span>
        </div><br>

        <div class="picker-wrapper">
            <input type="color" id="pick7" class="color-picker-sq" oninput="syncPickerToText(7, 2)">
            <input type="text" id="color7" placeholder="#0000FF" oninput="updateColors(2); syncTextToPicker(7)">
            <input type="range" id="weight7" min="0" max="100" value="25" oninput="updateColors(2)">
            <span id="closestColor7"></span>
        </div><br>

        <div class="picker-wrapper">
            <input type="color" id="pick8" class="color-picker-sq" oninput="syncPickerToText(8, 2)">
            <input type="text" id="color8" placeholder="#FFFF00" oninput="updateColors(2); syncTextToPicker(8)">
            <input type="range" id="weight8" min="0" max="100" value="25" oninput="updateColors(2)">
            <span id="closestColor8"></span>
        </div>
    </div>

    <div class="grid" id="results2"></div>
    <div id="copied-message2" class="copied"></div>
    
    <hr>
    <section id="image-palette-section">
        <h2>üñºÔ∏è Image Color Palette</h2>
        <div id="image-drop-area">
            <p>Paste an image (Ctrl+V), Drag & Drop a file, or Click to Upload. Click on image to pick a pixel color.</p>
            <canvas id="image-canvas" width="256" height="256"></canvas>
            <input type="file" id="image-upload" accept="image/*" style="display: none;">
        </div>
        
        <div class="grid">
            <div id="pixel-color-container">
                </div>
            <div id="dominant-colors-container" style="display: contents;"></div>
        </div>
        <div id="copied-message-image" class="copied"></div>
    </section>

    <script>
        // NOTE: colorfromHex, RGBAToHex, getClosestNamedColor, and namedWebColors are assumed to be loaded from colorConversion.js

        // --- NEW SYNC LOGIC ---
        function syncPickerToText(id, mixerNum) {
            const picker = document.getElementById(`pick${id}`);
            const textInput = document.getElementById(`color${id}`);
            textInput.value = picker.value.toUpperCase();
            updateColors(mixerNum);
        }

        function syncTextToPicker(id) {
            const picker = document.getElementById(`pick${id}`);
            const textInput = document.getElementById(`color${id}`);
            // Use your existing parseColor to handle names like "red"
            const rgba = parseColor(textInput.value);
            if (rgba) {
                // <input type="color"> requires 7-character hex (#RRGGBB)
                const hex = RGBAToHex({r: rgba.r, g: rgba.g, b: rgba.b, a: 255}).substring(0, 7);
                picker.value = hex;
            }
        }
        // ----------------------
        
        // --- HSL Conversion for Dominant Color Bias ---
        function RGBToHSL(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            // Return L (Lightness/Value) normalized to 0-100 for comparison
            return { h: h, s: s, l: l * 100 }; 
        }

        // --- EXISTING COLOR MIXER LOGIC ---

        function parseColor(input) {
            const colorHex = namedWebColors[input.toLowerCase()] || input;
            try { return colorfromHex(colorHex); } catch(e) { return null; }
        }

        function blendColors(colors, weights) {
            const totalWeight = weights.reduce((acc, weight) => acc + weight, 0);
            if (totalWeight === 0) {
                return { r: 0, g: 0, b: 0, a: 255 };
            }
            const normalizedWeights = weights.map(weight => weight / totalWeight);
            const blended = colors.reduce((acc, color, index) => {
                acc.r += color.r * normalizedWeights[index];
                acc.g += color.g * normalizedWeights[index];
                acc.b += color.b * normalizedWeights[index];
                acc.a += color.a * normalizedWeights[index];
                return acc;
            }, { r: 0, g: 0, b: 0, a: 0 });

            return { r: Math.round(blended.r), g: Math.round(blended.g), b: Math.round(blended.b), a: Math.round(blended.a) };
        }

        function invertColor(color) {
            return { r: 255 - color.r, g: 255 - color.g, b: 255 - color.b, a: color.a };
        }

        function shadeColor(color, percent) {
            const factor = percent / 100;
            return {
                r: Math.min(255, Math.max(0, Math.round(color.r + factor * (255 - color.r)))),
                g: Math.min(255, Math.max(0, Math.round(color.g + factor * (255 - color.g)))),
                b: Math.min(255, Math.max(0, Math.round(color.b + factor * (255 - color.b)))),
                a: color.a
            };
        }

        function pastelColor(color) {
            return shadeColor(color, 70);
        }

        function vibrantColor(color) {
            return shadeColor(color, -70);
        }

        function hueShift(color, degrees) {
            const r = color.r / 255;
            const g = color.g / 255;
            const b = color.b / 255;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }

            h = (h * 360 + degrees) % 360;
            if (h < 0) h += 360;
            h /= 360;

            let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            let p = 2 * l - q;
            const r2 = Math.round(hue2rgb(p, q, h + 1/3) * 255);
            const g2 = Math.round(hue2rgb(p, q, h) * 255);
            const b2 = Math.round(hue2rgb(p, q, h - 1/3) * 255);

            return { r: r2, g: g2, b: b2, a: color.a };
        }

        function hue2rgb(p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
        }

		function equalColors(a,b) {
			if(!a || !b) return false;
			return a.r == b.r && a.g == b.g && a.b == b.b && a.a == b.a;
		}
		
		function colorName(rgba) {
      if(!rgba) return '';
			const closestColorName = getClosestNamedColor(rgba);
			if(closestColorName == '') return '';
			const closestColorHex = namedWebColors[closestColorName];
			const closestColorRGBA = colorfromHex(closestColorHex);
			const almost = equalColors(rgba, closestColorRGBA) ? '' : " ‚âà";
			return `${closestColorName}${almost}`;
		}

        function updateColors(mixer) {
            const startIdx = 1 + (mixer - 1) * 4;
            const colorInputs = [
                document.getElementById(`color${startIdx}`).value,
                document.getElementById(`color${startIdx+1}`).value,
                document.getElementById(`color${startIdx+2}`).value,
                document.getElementById(`color${startIdx+3}`).value
            ];

            const weights = [
                colorInputs[0] ? Number(document.getElementById(`weight${startIdx}`).value) : 0,
                colorInputs[1] ? Number(document.getElementById(`weight${startIdx+1}`).value) : 0,
                colorInputs[2] ? Number(document.getElementById(`weight${startIdx+2}`).value) : 0,
                colorInputs[3] ? Number(document.getElementById(`weight${startIdx+3}`).value) : 0
            ];

            const parsedColors = colorInputs.map(parseColor).filter((c, index) => c && weights[index] > 0);
            const filteredWeights = weights.filter((w, index) => colorInputs[index] && w > 0);
            const results = document.getElementById(`results${mixer}`);
            results.innerHTML = '';

            colorInputs.forEach((input, index) => {
                const displayIdx = index + startIdx;
                if (input) {
                    const color = parseColor(input);
                    document.getElementById(`closestColor${displayIdx}`).textContent = `${colorName(color)}`;
                } else {
                    document.getElementById(`closestColor${displayIdx}`).textContent = '';
                }
            });

            if (parsedColors.length === 0) return;

            const blendedColor = blendColors(parsedColors, filteredWeights);

            function addColorBox(color, label) {
                const hex = RGBAToHex(color);
                // Updated label format to include HEX in the label for clarity
                results.innerHTML += `
                    <div class="color-box" style="background-color: ${hex};" onclick="copyToClipboard('${hex}', ${mixer})">
                        <div class="color-label">${label} <br>${hex} ${colorName(color)}</div>
                    </div>
                `;
            }

            addColorBox(blendedColor, `Blended`);
            addColorBox(invertColor(blendedColor), `Inverse`);
            addColorBox(pastelColor(blendedColor), `Pastel`);
            addColorBox(vibrantColor(blendedColor), `Vibrant`);
            addColorBox(shadeColor(blendedColor, 20), `Lighter`);
            addColorBox(shadeColor(blendedColor, -20), `Darker`);
            addColorBox(hueShift(blendedColor, 120), `Tri-chromic 1`);
            addColorBox(hueShift(blendedColor, 240), `Tri-chromic 2`);
            addColorBox(hueShift(blendedColor, 90), `Tetra-chromic 1`);
            addColorBox(hueShift(blendedColor, 180), `Tetra-chromeic 2`);
            addColorBox(hueShift(blendedColor, 270), `Tetra-chromeic 3`);
        }

        function copyToClipboard(text, mixer) {
            const textarea = document.createElement("textarea");
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand("copy");
            document.body.removeChild(textarea);

            const copiedMessage = document.getElementById(`copied-message${mixer}`);
            if (copiedMessage) {
                copiedMessage.textContent = `Copied ${text} to clipboard!`;
                setTimeout(() => {
                    copiedMessage.textContent = "";
                }, 2000);
            }
            // For the image palette, use a dedicated message element
            const imageCopiedMessage = document.getElementById('copied-message-image');
            if (imageCopiedMessage && mixer === 0) {
                 imageCopiedMessage.textContent = `Copied ${text} to clipboard!`;
                setTimeout(() => {
                    imageCopiedMessage.textContent = "";
                }, 2000);
            }
        }
        
        // --- IMAGE PALETTE LOGIC ---
        
        const canvas = document.getElementById('image-canvas');
        const ctx = canvas.getContext('2d');
        const dropArea = document.getElementById('image-drop-area');
        const imageUpload = document.getElementById('image-upload');
        const PIXEL_COLOR_CONTAINER = document.getElementById('pixel-color-container');
        const DOMINANT_COLORS_CONTAINER = document.getElementById('dominant-colors-container');


        // 1. Image Loading (File Upload, Drag & Drop, Paste)
        dropArea.addEventListener('click', (e) => {
            if (e.target.id !== 'image-canvas' && e.target.tagName !== 'BUTTON') {
                 imageUpload.click();
            }
        });
        imageUpload.addEventListener('change', (e) => {
            if (e.target.files.length) {
                loadImageFromFile(e.target.files[0]);
            }
        });

        // Drag & Drop
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
        });
        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => dropArea.style.borderColor = '#0056b3', false);
        });
        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => dropArea.style.borderColor = '#6c757d', false);
        });
        dropArea.addEventListener('drop', (e) => {
            const dt = e.dataTransfer;
            const file = dt.files[0];
            const items = dt.items;

            if (file && file.type.startsWith('image/')) {
                loadImageFromFile(file);
            } else if (items) {
                for (let i = 0; i < items.length; i++) {
                    if (items[i].kind === 'file' && items[i].type.startsWith('image/')) {
                        loadImageFromFile(items[i].getAsFile());
                        return;
                    }
                }
            }
        }, false);

        // Paste
        document.addEventListener('paste', (e) => {
            for (let i = 0; i < e.clipboardData.items.length; i++) {
                const item = e.clipboardData.items[i];
                if (item.type.indexOf('image') !== -1) {
                    loadImageFromFile(item.getAsFile());
                    e.preventDefault(); 
                    break;
                }
            }
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function loadImageFromFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                drawImageOnCanvas(e.target.result);
            };
            reader.readAsDataURL(file);
        }

        function drawImageOnCanvas(dataURL) {
            const img = new Image();
            img.crossOrigin = 'Anonymous';
            img.onload = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                let targetWidth = img.width;
                let targetHeight = img.height;
                
                // Scale the image down to fit the 256x256 canvas area (display limit)
                const max_size = 256;
                const ratio = Math.min(max_size / targetWidth, max_size / targetHeight);
                
                if (ratio < 1) {
                    targetWidth *= ratio;
                    targetHeight *= ratio;
                }
                
                // Center the image within the 256x256 canvas
                const x_offset = (canvas.width - targetWidth) / 2;
                const y_offset = (canvas.height - targetHeight) / 2;

                ctx.drawImage(img, x_offset, y_offset, targetWidth, targetHeight);
                dropArea.querySelector('p').style.display = 'none';
                findDominantColors();
            };
            img.onerror = () => {
                alert("Error loading image. Ensure it's a valid image file and not from a cross-origin source without CORS headers.");
                dropArea.querySelector('p').style.display = 'block';
            }
            img.src = dataURL;
        }


        // 2. Pixel Color Picker

        canvas.addEventListener('click', getPixelColor);

        function getPixelColor(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            PIXEL_COLOR_CONTAINER.innerHTML = '';
            
            try {
                const pixel = ctx.getImageData(x, y, 1, 1).data;

                if (pixel[3] < 50) { // Check for near-transparency/background
                    return;
                }
                
                const r = pixel[0];
                const g = pixel[1];
                const b = pixel[2];

                const color = {r, g, b, a: pixel[3]};
                
                const hex = RGBAToHex(color);
                
                // --- NEW CODE: Automatically copy the hex code to clipboard ---
                copyToClipboard(hex, 0); 
                // -----------------------------------------------------------------
                
                // Use the existing addColorBox style for display
                const colorBoxHTML = createColorBoxHTML(color, 'Pixel Color');
                PIXEL_COLOR_CONTAINER.innerHTML = colorBoxHTML;
                
            } catch (error) {
                 console.error(error);
                 alert("Cannot read pixel data. The canvas is likely tainted by a cross-origin image.");
            }
        }
        
        function createColorBoxHTML(color, label) {
            const hex = RGBAToHex(color);
            // Label format: [Label] ([#HEX]) [Closest Named Color] [‚âà]
            const name = colorName(color);
            const labelText = `${label} <br>${hex} ${name}`;
            
            // The entire box is the copy target, copying the hex value (mixer 0 is general clipboard)
            return `
                <div class="color-box" style="background-color: ${hex};" onclick="copyToClipboard('${hex}', 0)">
                    <div class="color-label">${labelText}</div>
                </div>
            `;
        }

        // 3. Dominant Color Extraction (Quantization with Log-Scaling and Perceptual Weighting)

        function findDominantColors() {
            dominantColors = [];
            DOMINANT_COLORS_CONTAINER.innerHTML = '';
            
            try {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const step = 4; // Sample every 4th pixel 
                const binSize = 16; 
                const colorMap = {}; 

                for (let i = 0; i < data.length; i += 4 * step) {
                    if (data[i + 3] < 50) continue; // Skip mostly transparent/background
                    
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    const r_bin = Math.floor(r / binSize) * binSize;
                    const g_bin = Math.floor(g / binSize) * binSize;
                    const b_bin = Math.floor(b / binSize) * binSize;

                    const key = `${r_bin},${g_bin},${b_bin}`;

                    if (!colorMap[key]) {
                        colorMap[key] = { r: 0, g: 0, b: 0, count: 0, avg_r: 0, avg_g: 0, avg_b: 0, hsl: {} };
                    }
                    
                    colorMap[key].r += r;
                    colorMap[key].g += g;
                    colorMap[key].b += b;
                    colorMap[key].count++;
                }

                // Apply PERCEPTUAL LOG-SCALING (V9)
                Object.values(colorMap).forEach(bin => {
                    const avg_r = bin.r / bin.count;
                    const avg_g = bin.g / bin.count;
                    const avg_b = bin.b / bin.count;
                    const hsl = RGBToHSL(avg_r, avg_g, avg_b);
                    
                    bin.avg_r = Math.round(avg_r);
                    bin.avg_g = Math.round(avg_g);
                    bin.avg_b = Math.round(avg_b);
                    bin.hsl = hsl; // Store HSL for final sort

                    // Base multiplier is 1 (no change)
                    let perceptualMultiplier = 1.0; 
                    
                    // 1. Lightness (L) Multiplier: Amplify the score based on lightness
                    if (hsl.l > 80) { // Very Light (Sweater) - High Priority
                        perceptualMultiplier = Math.max(perceptualMultiplier, 2.5); 
                    } else if (hsl.l > 40 && hsl.l <= 70) { // Mid-Lightness (Skin/Mid-tones)
                        perceptualMultiplier = Math.max(perceptualMultiplier, 2.2); 
                    } else if (hsl.l < 20) { // Very Dark (Shadows/Coat)
                        perceptualMultiplier = Math.max(perceptualMultiplier, 1.3); 
                    } 

                    // 2. Saturation (S) Multiplier: HIGHLY Amplify saturated colors (Hair/Sunset)
                    if (hsl.s > 0.3) { 
                        perceptualMultiplier += 2.0 * hsl.s; 
                    }

                    // Log-Scale the count to flatten large numerical differences
                    const logCount = Math.log(bin.count);

                    // New Biased Score: Log-Count * Perceptual Multiplier
                    bin.biasedScore = logCount * perceptualMultiplier;
                });

                // Step 1: Filter and sort by the final calculated Biased Score
                const sortedBinsByScore = Object.values(colorMap)
                    // Filter out bins that only have a single pixel, as they create noise after log scaling
                    .filter(bin => bin.count > 1) 
                    .sort((a, b) => b.biasedScore - a.biasedScore);

                const numColors = Math.min(4, sortedBinsByScore.length);
                
                // Step 2: Take the top N colors, and re-sort them for presentation
                let finalDominantColors = sortedBinsByScore.slice(0, numColors);

                // FINAL SORTING FOR PRESENTATION (V10)
                // Sort Priority:
                // 1. Saturation (highest first) - to prioritize rich colors like hair/sunset
                // 2. Darkness (lowest Lightness first) - to prioritize deep shadows over mid-tones
                finalDominantColors.sort((a, b) => {
                    // Primary Key: Saturation (higher is better)
                    const satDiff = b.hsl.s - a.hsl.s;
                    if (satDiff !== 0) return satDiff;

                    // Secondary Key: Lightness (lower is better, i.e., darker colors first)
                    return a.hsl.l - b.hsl.l;
                });

                
                for (let i = 0; i < finalDominantColors.length; i++) {
                    const bin = finalDominantColors[i];
                    
                    const color = {r: bin.avg_r, g: bin.avg_g, b: bin.avg_b};
                    const hex = RGBAToHex(color);
                    dominantColors.push(hex);
                    
                    const label = `Dominant ${i + 1}`;
                    const colorBoxHTML = createColorBoxHTML(color, label);
                    DOMINANT_COLORS_CONTAINER.innerHTML += colorBoxHTML;
                }

            } catch (e) {
                console.error("Could not read canvas data.", e);
                DOMINANT_COLORS_CONTAINER.innerHTML = '<div style="color:red; width: 100%;">Error extracting palette (Cross-Origin issue).</div>';
            }
        }

        // Initial call to populate mixers
        document.addEventListener('DOMContentLoaded', () => {
             // Sync pickers to initial placeholder or values
             for(let i=1; i<=8; i++) syncTextToPicker(i);
             updateColors(1);
             updateColors(2);
        });
    </script>
</body>
</html>